# **Blogs of *Algorithm***

## Contact me

* Blog -> <https://cugtyt.github.io/blog/index>
* Email -> <cugtyt@qq.com>
* GitHub -> [Cugtyt@GitHub](https://github.com/Cugtyt)

---

## **leetcode系列**

> [leetcode 6 旋转链表](https://cugtyt.github.io/blog/algo/2020/0101)

> [leetcode 667 优美的排列 II](https://cugtyt.github.io/blog/algo/2020/0102)

> [leetcode 1019 链表中的下一个更大节点](https://cugtyt.github.io/blog/algo/2020/0103)

> [leetcode 1233 删除子文件夹](https://cugtyt.github.io/blog/algo/2020/0104)

> [leetcode 743 网络延迟时间](https://cugtyt.github.io/blog/algo/2020/0105)

> [leetcode 785 判断二分图](https://cugtyt.github.io/blog/algo/2020/0106)

> [leetcode 90 子集 II](https://cugtyt.github.io/blog/algo/2020/0107)

> [leetcode 438 找到字符串中所有字母异位词](https://cugtyt.github.io/blog/algo/2020/0108)

> [leetcode 1286 字母组合迭代器](https://cugtyt.github.io/blog/algo/2020/0109)

> [leetcode 143 重排链表](https://cugtyt.github.io/blog/algo/2020/0110)

> [leetcode 1054 距离相等的条形码](https://cugtyt.github.io/blog/algo/2020/0111)

> [leetcode 199 二叉树的右视图](https://cugtyt.github.io/blog/algo/2020/0112)

> [leetcode 134 加油站](https://cugtyt.github.io/blog/algo/2020/0113)

> [leetcode 1261 在受污染的二叉树中查找元素](https://cugtyt.github.io/blog/algo/2020/0115)

> [leetcode 1023 驼峰式匹配](https://cugtyt.github.io/blog/algo/2020/0116)

> [leetcode 17 电话号码的字母组合](https://cugtyt.github.io/blog/algo/2020/0117)

> [leetcode 946 验证栈序列](https://cugtyt.github.io/blog/algo/2020/0118)

> [leetcode 851 喧闹和富有](https://cugtyt.github.io/blog/algo/2020/0119)

> [leetcode 894 所有可能的满二叉树](https://cugtyt.github.io/blog/algo/2020/0120)

> [leetcode 1053 交换一次的先前排列](https://cugtyt.github.io/blog/algo/2020/0121)

> [leetcode 763 划分字母区间](https://cugtyt.github.io/blog/algo/2020/0122)

> [leetcode 63 不同路径 II](https://cugtyt.github.io/blog/algo/2020/0123)

> [leetcode 72 编辑距离](https://cugtyt.github.io/blog/algo/2020/0124)

> [leetcode 87 扰乱字符串](https://cugtyt.github.io/blog/algo/2020/0125)

> [leetcode 96 不同的二叉搜索树](https://cugtyt.github.io/blog/algo/2020/0126)

> [leetcode 213 打家劫舍 II](https://cugtyt.github.io/blog/algo/2020/0127)

> [leetcode 300 最长上升子序列](https://cugtyt.github.io/blog/algo/2020/0128)

> [leetcode 397 整数替换](https://cugtyt.github.io/blog/algo/2020/0129)

> [leetcode 11 盛最多水的容器](https://cugtyt.github.io/blog/algo/2020/0130)

> [leetcode 477 汉明距离总和](https://cugtyt.github.io/blog/algo/2020/0201)

> [leetcode 3 无重复字符的最长子串](https://cugtyt.github.io/blog/algo/2020/0202)

> [leetcode 10 正则表达式匹配](https://cugtyt.github.io/blog/algo/2020/0203)

> [leetcode 15 三数之和](https://cugtyt.github.io/blog/algo/2020/0204)

> [leetcode 19 删除链表的倒数第N个节点](https://cugtyt.github.io/blog/algo/2020/0205)

> [leetcode 4 寻找两个有序数组的中位数](https://cugtyt.github.io/blog/algo/2020/0206)

> [leetcode 23 合并K个排序链表](https://cugtyt.github.io/blog/algo/2020/0207)

> [leetcode 31 下一个排列](https://cugtyt.github.io/blog/algo/2020/0208)

> [leetcode 32 最长有效括号](https://cugtyt.github.io/blog/algo/2020/0209)

> [leetcode 33 搜索旋转排序数组](https://cugtyt.github.io/blog/algo/2020/0210)

> [leetcode 34 在排序数组中查找元素的第一个和最后一个位置](https://cugtyt.github.io/blog/algo/2020/0211)

> [leetcode 39 组合总和](https://cugtyt.github.io/blog/algo/2020/0212)

> [leetcode 41 缺失的第一个正数](https://cugtyt.github.io/blog/algo/2020/0213)

> [leetcode 46 全排列](https://cugtyt.github.io/blog/algo/2020/0214)

> [leetcode 48 旋转图像](https://cugtyt.github.io/blog/algo/2020/0215)

> [leetcode 53 最大子序和](https://cugtyt.github.io/blog/algo/2020/0216)

> [leetcode 55 跳跃游戏](https://cugtyt.github.io/blog/algo/2020/0217)

> [leetcode 56 合并区间](https://cugtyt.github.io/blog/algo/2020/0218)

> [leetcode 62 不同路径](https://cugtyt.github.io/blog/algo/2020/0219)

> [leetcode 64 最小路径和](https://cugtyt.github.io/blog/algo/2020/0220)

> [leetcode 76 最小覆盖子串](https://cugtyt.github.io/blog/algo/2020/0221)

> [leetcode 78 子集](https://cugtyt.github.io/blog/algo/2020/0222)

> [leetcode 79 单词搜索](https://cugtyt.github.io/blog/algo/2020/0223)

> [leetcode 84 柱状图中最大的矩形](https://cugtyt.github.io/blog/algo/2020/0224)

> [leetcode 85 最大矩形](https://cugtyt.github.io/blog/algo/2020/0225)

> [leetcode 94 二叉树的中序遍历](https://cugtyt.github.io/blog/algo/2020/0226)

> [leetcode 98 验证二叉搜索树](https://cugtyt.github.io/blog/algo/2020/0227)

> [leetcode 101 对称二叉树](https://cugtyt.github.io/blog/algo/2020/0228)

> [leetcode 102 二叉树的层次遍历](https://cugtyt.github.io/blog/algo/2020/0229)

> [leetcode 105 从前序与中序遍历序列构造二叉树](https://cugtyt.github.io/blog/algo/2020/0301)

> [leetcode 114 二叉树展开为链表](https://cugtyt.github.io/blog/algo/2020/0302)

> [leetcode 124 二叉树中的最大路径和](https://cugtyt.github.io/blog/algo/2020/0303)

> [leetcode 128 最长连续序列](https://cugtyt.github.io/blog/algo/2020/0304)

> [leetcode 138 复制带随机指针的链表](https://cugtyt.github.io/blog/algo/2020/0305)

> [leetcode 139 单词拆分](https://cugtyt.github.io/blog/algo/2020/0306)

> [leetcode 141 环形链表](https://cugtyt.github.io/blog/algo/2020/0307)

> [leetcode 146 LRU缓存机制](https://cugtyt.github.io/blog/algo/2020/0308)

> [leetcode 148 排序链表](https://cugtyt.github.io/blog/algo/2020/0309)

> [leetcode 152 乘积最大子序列](https://cugtyt.github.io/blog/algo/2020/0310)

> [leetcode 155 最小栈](https://cugtyt.github.io/blog/algo/2020/0311)

> [leetcode 200 岛屿数量](https://cugtyt.github.io/blog/algo/2020/0312)

> [leetcode 207 课程表](https://cugtyt.github.io/blog/algo/2020/0313)

> [leetcode 208 实现 Trie (前缀树)](https://cugtyt.github.io/blog/algo/2020/0314)

> [leetcode 221 最大正方形](https://cugtyt.github.io/blog/algo/2020/0315)

> [leetcode 234 回文链表](https://cugtyt.github.io/blog/algo/2020/0316)

> [leetcode 236 二叉树的最近公共祖先](https://cugtyt.github.io/blog/algo/2020/0317)

> [leetcode 238 除自身以外数组的乘积](https://cugtyt.github.io/blog/algo/2020/0318)

> [leetcode 239 滑动窗口最大值](https://cugtyt.github.io/blog/algo/2020/0319)

> [leetcode 240 搜索二维矩阵 II](https://cugtyt.github.io/blog/algo/2020/0320)

> [leetcode 279 完全平方数](https://cugtyt.github.io/blog/algo/2020/0321)

> [leetcode 287 寻找重复数](https://cugtyt.github.io/blog/algo/2020/0322)

> [leetcode 295 数据流的中位数](https://cugtyt.github.io/blog/algo/2020/0323)

> [leetcode 297 二叉树的序列化与反序列化](https://cugtyt.github.io/blog/algo/2020/0324)

---

## **剑指Offer系列**

> [二维数组中的查找](https://cugtyt.github.io/blog/algo/2019/1114)

> [替换空格](https://cugtyt.github.io/blog/algo/2019/1115)

> [从尾到头打印链表](https://cugtyt.github.io/blog/algo/2019/1116)

> [重建二叉树](https://cugtyt.github.io/blog/algo/2019/1117)

> [用栈实现队列](https://cugtyt.github.io/blog/algo/2019/1124)

> [旋转数组的最小数字](https://cugtyt.github.io/blog/algo/2019/1125)

> [斐波那契数列、跳台阶、矩形覆盖](https://cugtyt.github.io/blog/algo/2019/1126)

> [变态跳台阶](https://cugtyt.github.io/blog/algo/2019/1127)

> [二进制中1的个数](https://cugtyt.github.io/blog/algo/2019/1128)

> [数值的整数次方](https://cugtyt.github.io/blog/algo/2019/1130)

> [调整数组顺序使奇数位于偶数前面](https://cugtyt.github.io/blog/algo/2019/1201)

> [链表中倒数第k个结点](https://cugtyt.github.io/blog/algo/2019/1202)

> [反转链表](https://cugtyt.github.io/blog/algo/2019/1203)

> [合并两个排序的链表](https://cugtyt.github.io/blog/algo/2019/1204)

> [树的子结构](https://cugtyt.github.io/blog/algo/2019/1205)

> [二叉树的镜像](https://cugtyt.github.io/blog/algo/2019/1206)

> [顺时针打印矩阵](https://cugtyt.github.io/blog/algo/2019/1207)

> [包含min函数的栈](https://cugtyt.github.io/blog/algo/2019/1208)

> [栈的压入、弹出序列](https://cugtyt.github.io/blog/algo/2019/1209)

> [从上往下打印二叉树](https://cugtyt.github.io/blog/algo/2019/1210)

> [二叉搜索树的后序遍历序列](https://cugtyt.github.io/blog/algo/2019/1211)

> [二叉树中和为某一值的路径](https://cugtyt.github.io/blog/algo/2019/1212)

> [数组中出现次数超过一半的数字](https://cugtyt.github.io/blog/algo/2019/1221)

> [最小的K个数](https://cugtyt.github.io/blog/algo/2019/1225)

> [连续子数组的最大和](https://cugtyt.github.io/blog/algo/2019/1228)

> [从1到n整数中1出现的次数](https://cugtyt.github.io/blog/algo/2019/1229)

> [把数组排成最小的数](https://cugtyt.github.io/blog/algo/2019/1230)

> [丑数](https://cugtyt.github.io/blog/algo/2019/1231)

---

## [**拼歌单 -- 多重背包转01背包**](https://cugtyt.github.io/blog/algo/2019/1105)

> 计算动态规划表，转一维空间

---

## [**图直径**](https://cugtyt.github.io/blog/algo/2019/1102)

> 通过BFS遍历图看作树的形式，通过一次遍历找到最深的节点，反向遍历得到最长的节点距离

---

## [**Non-overlapping Intervals问题**](https://cugtyt.github.io/blog/algo/2018/0914)

> 通过有序来统计交叉

---

## [**Matchsticks to Square问题**](https://cugtyt.github.io/blog/algo/2018/0823)

> DFS解决数组均分问题

---

## [**Minimum Window Substring问题**](https://cugtyt.github.io/blog/algo/2018/2018081514)

> 使用统计的方法比较无序和不连续的串

---

## [**Find All Anagrams in a String问题**](https://cugtyt.github.io/blog/algo/2018/2018081318)

> 对于子串的比较可以使用计数的方式，滑动窗每次对改变的元素修改，而不是重新计算

---

## [**Network Delay Time问题**](https://cugtyt.github.io/blog/algo/2018/2018080612)

> 类似动态规划，有向图，最短时间

---

## [**Reverse Bits问题**](https://cugtyt.github.io/blog/algo/2018/2018080215)

> 用位运算解，二分法可以优化

---

## [**Reaching Points**](https://cugtyt.github.io/blog/algo/2018/201807231703)

> 缩小问题

---

## [**青蛙过河问题**](https://cugtyt.github.io/blog/algo/2018/201804291948)

> 深度优先搜索

---

## [**Python中使用序列解决不确定循环层数的遍历问题**](https://cugtyt.github.io/blog/algo/2018/201803271441)

> 当循环层数不确定时如何遍历

---

## [**小行星碰撞**](https://cugtyt.github.io/blog/algo/2018/201802282113)

> 利用栈计算四则运算的思想解决碰撞消除问题

---

## [**买卖股票的最佳任意次交易（带间隔）**](https://cugtyt.github.io/blog/algo/2018/201802281634)

> 多次交易，但是交易间需要间隔时间

---

## [**买卖股票的最佳K次交易**](https://cugtyt.github.io/blog/algo/2018/201802281619)

> 借用两次交易的思路，扩展到K次

---

## [**买卖股票的最佳两次交易**](https://cugtyt.github.io/blog/algo/2018/201802281555)

> 通过四次max来计算买入卖出的最大利润

---

## [**买卖股票的最佳一次交易**](https://cugtyt.github.io/blog/algo/2018/201802172140)

> 与最长子数组问题类似

---

## [**找到链表中的环**](https://cugtyt.github.io/blog/algo/2018/201802121954)

> 如何确定链表中环的起点

---

## [**找到出现多次的数**](https://cugtyt.github.io/blog/algo/2018/201802121450)

> n+1个1~n中的数，某个数字会多次出现，如何找到

---

## [**字符串中第一个只出现一次的字符**](https://cugtyt.github.io/blog/algo/2018/201802061802)

> 字符串中第一个只出现一次的字符

---

## [**动态规划求解不同子串数目**](https://cugtyt.github.io/blog/algo/2018/201802052106)

> 在S串中找匹配T子串的数量，详见内容

---